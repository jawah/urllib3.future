diff --git a/tests/unit/test_awsrequest.py b/tests/unit/test_awsrequest.py
index 4118d74..7dc7414 100644
--- a/tests/unit/test_awsrequest.py
+++ b/tests/unit/test_awsrequest.py
@@ -34,6 +34,7 @@ from botocore.compat import file_type
 from botocore.exceptions import UnseekableStreamError
 from tests import mock, unittest
 
+import pytest
 
 class IgnoreCloseBytesIO(io.BytesIO):
     def close(self):
@@ -373,6 +374,7 @@ class TestAWSHTTPConnection(unittest.TestCase):
         conn.response_class.return_value = self.mock_response
         return conn
 
+    @pytest.mark.xfail(reason="https://github.com/urllib3/urllib3/pull/2565")
     def test_expect_100_continue_returned(self):
         with mock.patch('urllib3.util.wait_for_read') as wait_mock:
             # Shows the server first sending a 100 continue response
@@ -390,6 +392,7 @@ class TestAWSHTTPConnection(unittest.TestCase):
             # Now we should verify that our final response is the 200 OK
             self.assertEqual(response.status, 200)
 
+    @pytest.mark.xfail(reason="https://github.com/urllib3/urllib3/pull/2565")
     def test_handles_expect_100_with_different_reason_phrase(self):
         with mock.patch('urllib3.util.wait_for_read') as wait_mock:
             # Shows the server first sending a 100 continue response
@@ -415,6 +418,7 @@ class TestAWSHTTPConnection(unittest.TestCase):
             # continue.
             self.assertIn(b'body', s.sent_data)
 
+    @pytest.mark.xfail(reason="https://github.com/urllib3/urllib3/pull/2565")
     def test_expect_100_sends_connection_header(self):
         # When using squid as an HTTP proxy, it will also send
         # a Connection: keep-alive header back with the 100 continue
@@ -442,6 +446,7 @@ class TestAWSHTTPConnection(unittest.TestCase):
             response = conn.getresponse()
             self.assertEqual(response.status, 500)
 
+    @pytest.mark.xfail(reason="https://github.com/urllib3/urllib3/pull/2565")
     def test_expect_100_sends_connection_header_optional_continue(self):
         # When using squid as an HTTP proxy, it will also send
         # a Connection: keep-alive header back with the 100 continue
@@ -469,6 +474,7 @@ class TestAWSHTTPConnection(unittest.TestCase):
             response = conn.getresponse()
             self.assertEqual(response.status, 500)
 
+    @pytest.mark.xfail(reason="https://github.com/urllib3/urllib3/pull/2565")
     def test_expect_100_continue_sends_307(self):
         # This is the case where we send a 100 continue and the server
         # immediately sends a 307
@@ -491,6 +497,7 @@ class TestAWSHTTPConnection(unittest.TestCase):
             # Now we should verify that our final response is the 307.
             self.assertEqual(response.status, 307)
 
+    @pytest.mark.xfail(reason="https://github.com/urllib3/urllib3/pull/2565")
     def test_expect_100_continue_no_response_from_server(self):
         with mock.patch('urllib3.util.wait_for_read') as wait_mock:
             # Shows the server first sending a 100 continue response
@@ -596,6 +603,7 @@ class TestAWSHTTPConnection(unittest.TestCase):
         response = conn.getresponse()
         self.assertEqual(response.status, 200)
 
+    @pytest.mark.xfail(reason="https://github.com/urllib3/urllib3/pull/2565")
     def test_state_reset_on_connection_close(self):
         # This simulates what urllib3 does with connections
         # in its connection pool logic.

